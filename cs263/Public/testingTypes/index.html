<?xml version="1.0" encoding="UTF-8"?><html><head><meta charset="UTF-8"/><link href="../../styles/md-scroll.css" media="screen, projection, print" rel="stylesheet" type="text/css"/><link href="../../styles/md-scroll-ext.css" media="screen, projection, print" rel="stylesheet" type="text/css"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="../../styles/highlight.js/styles/googlecode.css" rel="stylesheet"/><script src="../../styles/highlight.js/highlight.min.js"> </script><script>hljs.initHighlightingOnLoad();</script><script src="../../styles/md-scroll.js" type="text/javascript"> </script><script src="../../styles/md-scroll-ext.js" type="text/javascript"> </script><script src="../../styles/rawdeflate.js" type="text/javascript"> </script><script src="../../styles/plantuml.js" type="text/javascript"> </script><script src="../../styles/mermaid.min.js" type="text/javascript"> </script><script type="text/javascript">
             window.MathJax = {
               tex2jax: {
               inlineMath: [ ['$','$'], ["\\(","\\)"] ],
               processEscapes: true
             }
           };
           </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"> </script><title>Types of Tests</title></head><body><script>sshowControl0 = { counter: 1,
             showNumber: 0, max: 1};
             window.onhashchange = hashHasChanged;</script><div class="navHeader" id="slideshowControlA0"><table class="navHeader"><tr class="slideshowcontrol"><td class="slideshowcontrolLeft"/><td class="slideshowcontrolMiddle">
<a class="imgLink" href="../../Directory/outline/index.html" title="Course home/outline"><img src="../../graphics/home.png"/></a>
<a href="mailto:tkennedy@odu.edu?subject=CS263%2C%20Types%20of%20Tests"><img src="../../graphics/email.png" title="Email to instructor"/></a><span style="margin: 0 32px;"/></td><td class="slideshowcontrolRight"/></tr></table></div><div class="mainBody"><div class="titleblock"><h1 class="title">Types of Tests</h1><h2 class="author">Thomas J. Kennedy</h2></div><div class="toc">Contents:<div class="toc-h1"><a href="#general-testing-techniques">1 General Testing Techniques</a></div><div class="toc-h2"><a href="#head-to-head-testing">1.1 Head-to-Head Testing</a></div><div class="toc-h2"><a href="#black-box-testing">1.2 Black-Box Testing</a></div><div class="toc-h2"><a href="#white-box-testing">1.3 White-Box Testing</a></div><div class="toc-h1"><a href="#formal-testing-frameworks">2 Formal Testing Frameworks</a></div><div class="toc-h2"><a href="#defining-a-test">2.1 Defining a Test</a></div><div class="toc-h2"><a href="#what-are-unit-integration-and-system-tests-">2.2 What are Unit, Integration and System Tests?</a></div></div><p>There are quite a few types of tests… They are better described as testing <em>techniques</em> or <em>methodologies.</em> We are interested in:</p>
    <ul>
  <li>
    <p><strong>General Testing Techniques</strong></p>
    
    <ul>
      <li>White-Box Testing</li>
      <li>Black-Box Testing</li>
      <li>Head-to-Head Testing</li>
    </ul>
  </li>
  <li>
    <p><strong>Formal Testing Frameworks</strong></p>
    
    <ul>
      <li>Unit Testing</li>
      <li>Integration Testing</li>
      <li>System Testing</li>
    </ul>
  </li>
</ul><a id="generaltestingtechniques"/><h1 id="general-testing-techniques">1 General Testing Techniques</h1><p>Let us focus on general testing techniques first.</p>
    <a id="headtoheadtesting"/><h2 id="head-to-head-testing">1.1 Head-to-Head Testing</h2><p>Head-to-head-testing is essentially comparing to sets of output:</p>
    <ul>
  <li>
  <p>“correct” (reference) output generated by hand (e.g., based on a requirements document) or from a known “correct” program.</p>
    </li>
  <li>
  <p>actual output generated by the program being evaluated.</p>
    </li>
</ul><a id="blackboxtesting"/><h2 id="black-box-testing">1.2 Black-Box Testing</h2><div class="noFloat"> </div><div class="sidebar pct50">
<p>Note that Unit Testing is a topic that will be discussed in a future lecture. For the moment… just remember that a unit test focuses on a single piece of code (e.g., a single function).</p>
    
</div><p>Black-Box testing involves writing tests for a “black box.”</p>
    <blockquote>
  <p>What is a “black box?”</p>
    
  <p>This type of testing focuses creating test data for a function, class, or program with a known interface, but whose implementation details are unknown.</p>
    
</blockquote><p>In fact… this technique is used in Test Driven Development (TDD) to write unit tests before actually implementing any code.</p>
    <p>Let us go through a quick example. Suppose you are provided the following function declaration and told to design a few tests.</p>
    <blockquote class="example" id="example1"><div class="exampleTitle">Example 1: Simple Addition Function</div>
<pre><code class="python"><br/>def add_two_integers(num1: int, num2: int) -&gt; int:
    """
    Add two integers (any combination of positive, negative, or zero) together.

    Args:
        num1: first number
        num2: second number

    Returns:
        sum of num1 and num2  (i.e., num1 + num2)

    Raises:

        ValueError if `num1` and `num1` are not in the range -10000 to 10000
        (inclusive).
    """
</code></pre>
</blockquote><p>As a point of reference both C++ Doxygen and Java Javadoc versions are listed below.</p>
    <div class="details"><span class="summary">C++ Documentation</span> <input id="but_details_d6e80" onclick="toggleDisplay('_details_d6e80')" type="button" value="+"/><div class="detailsBody" id="_details_d6e80" style="display: none;">
<pre><code class="cpp">/**
 * Add two integers (any combination of positive, negative, or zero) together.
 *
 * @param num1 - first number
 * @param num2 - second number
 *
 * @returns sum of num1 and num2  (i.e., num1 + num2)
 *
 * @pre (num1 &gt;= -10000 &amp;&amp; num1 &lt;= 10000) 
 *   &amp;&amp; (num2 &gt;= -10000 &amp;&amp; num2 &lt;= 10000) 
 */
int addTwoIntegers(const int num1, const int num2);
</code></pre>
</div></div><div class="details"><span class="summary">Java Documentation</span> <input id="but_details_d6e86" onclick="toggleDisplay('_details_d6e86')" type="button" value="+"/><div class="detailsBody" id="_details_d6e86" style="display: none;">
<pre><code class="java">    /**
     * Add two integers (any combination of positive, negative, or zero) together.
     *
     * @param num1 - first number
     * @param num2 - second number
     *
     * @returns sum of num1 and num2  (i.e., num1 + num2)
     *
     * @throws ArithmeticException if `num1` and `num1` are not in the range -10000
     * to 10000 (inclusive).
     */
    public int addTwoIntegers(const int num1, const int num2)
    {
        //...
    }
</code></pre>
</div></div><p>The function has full documentation. The constraints (e.g., preconditions) of the function are explicitly stated. All numbers must fall in the range $-10,000$ to $10,000$. We would want to test a few things:</p>
    <ul>
  <li>boundary conditions
    <ul>
      <li>combinations of 10,000 and -10,000</li>
      <li>combinations close 10,000 and -10,000 but still in the defined range</li>
    </ul>
  </li>
  <li>combinations of positive numbers</li>
  <li>combinations of negative numbers</li>
  <li>two zeroes</li>
  <li>combinations of negative numbers, zeroes, and positive numbers</li>
</ul><p>Since we know how to add (usually…), the correct sums can be computed by hand. When we obtain the definition of <code>add_two_integers</code> the results generated by the function can be compared to the known correct results.</p>
    <a id="whiteboxtesting"/><h2 id="white-box-testing">1.3 White-Box Testing</h2><p>White-Box testing complements Black-Box testing. While Black-Box testing ignores the code itself (instead focusing on interfaces and requirements), White-Box testing focuses on the code and all but ignores the requirements.</p>
    <p>White-Box testing often examines which lines of code are executed and which branches are taken. The process generally makes use of a tool such as</p>
    <ul>
  <li><code>gcov</code> (C++)</li>
  <li><code>jacoco</code> (Java)</li>
  <li><code>coverage.py</code> (Python)</li>
  <li>Tarpaulin (Rust)</li>
</ul><p>These are code coverage tools… used to track which lines of code are “touched” during a program’s normal execution (i.e., using the <code>main</code> driver function) or when some type of tests (e.g., Black-Box or Unit) are run.</p>
    <a id="formaltestingframeworks"/><h1 id="formal-testing-frameworks">2 Formal Testing Frameworks</h1><p>In previous lectures (within this course and in previous coursework) most tests were run manually. Formal testing frameworks (e.g., JUnit) allow the process to be automated.</p>
    <p>Suppose that we have a function that:</p>
    <ol>
  <li>accepts an integer</li>
  <li>adds one to the integer</li>
  <li>doubles that result</li>
  <li>returns the final result</li>
</ol><p>The function might have a signature in the form…</p>
    <pre><code class="python">def add_one_then_double(val: int) -&gt; int:
    pass
</code></pre><p><em>I have forgone pydoc documentation in this example.</em> Note the use of</p>
    <pre><code class="python">pass
</code></pre><p>This keyword is the Python equivalent of an empty block in C++…</p>
    <pre><code class="cpp">int add_one_then_double(const int val)
{
    return -1;
}
</code></pre><p>or Java…</p>
    <pre><code class="java">public int add_one_then_double(final int val)
{
    return -1;
}
</code></pre><p>or Rust…</p>
    <pre><code class="Rust">fn add_one_then_double(val: u32) -&gt; u32
{
    return 0 as u32;
}
</code></pre><p>However, our focus is on Python. While writing good tests is a discussion in its own right…</p>
    <a id="definingatest"/><h2 id="defining-a-test">2.1 Defining a Test</h2><p>It is still possible to write a simple test. The key is knowing <em>a priori</em> (i.e., ahead of time) what output will be generated for a given input. Assuming <code>add_one_then_double</code> were fully documented… we could compute the following…</p>
    <table>
  <thead>
    <tr>
      <th align="right">val </th>
      <th align="right">plus 1 </th>
      <th align="right">double </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="right">0 </td>
      <td align="right">1 </td>
      <td align="right">2 </td>
    </tr>
    <tr>
      <td align="right">1 </td>
      <td align="right">2 </td>
      <td align="right">4 </td>
    </tr>
    <tr>
      <td align="right">2 </td>
      <td align="right">3 </td>
      <td align="right">6 </td>
    </tr>
    <tr>
      <td align="right">3 </td>
      <td align="right">4 </td>
      <td align="right">8 </td>
    </tr>
    <tr>
      <td align="right">4 </td>
      <td align="right">5 </td>
      <td align="right">10 </td>
    </tr>
  </tbody>
</table><p>A Python unit test written using <a href="https://docs.pytest.org/en/7.4.x/" target="_blank">pytest</a> and <a href="https://github.com/hamcrest/PyHamcrest/" target="_blank">PyHamcrest</a> would start off similar to…</p>
    <pre><code class="python">def test_quick_demo():
    assert_that(add_one_then_double(0), is_(equal_to(2)))
    assert_that(add_one_then_double(1), is_(equal_to(4)))
    assert_that(add_one_then_double(2), is_(equal_to(6)))
    assert_that(add_one_then_double(3), is_(equal_to(8)))
    assert_that(add_one_then_double(4), is_(equal_to(10)))
</code></pre><p>The syntax (and missing <code>import</code> statements) will be discussed in a separate (maybe even the next) lecture. For now… we just need to note that any properly implemented version of <code>add_one_then_double</code> will pass the <code>test_quick_demo</code> unit test.</p>
    <a id="whatareunitintegrationandsystemtests"/><h2 id="what-are-unit-integration-and-system-tests-">2.2 What are Unit, Integration and System Tests?</h2><p>The three types of tests can be defined as follows…</p>
    <ul>
  <li>
  <p><strong>Unit Test</strong> - a type of test that focuses on a single piece of code (e.g., function, module, or class).</p>
    </li>
  <li>
    <p><strong>Integration Test</strong> - a type of test that focuses on multiple pieces of code working together (two or three steps), e.g.,</p>
    
    <ul>
      <li>
      <p>a function that calls a sequence of functions</p>
    </li>
      <li>
      <p>a class that interacts with another class</p>
    </li>
    </ul>
  </li>
  <li>
  <p><strong>System Test</strong> - a type of test that focuses on a program from start to finish. These tests evaluate the results of an entire sequence of function calls and class interactions (i.e., multiple steps).</p>
    </li>
</ul></div><script>sshowControl0 = { counter: 1,
             showNumber: 0, max: 1};
             window.onhashchange = hashHasChanged;</script><div class="navFooter" id="slideshowControl0"><table class="navFooter"><tr class="slideshowcontrol"><td class="slideshowcontrolLeft"/><td class="slideshowcontrolMiddle">
<a class="imgLink" href="../../Directory/outline/index.html" title="Course home/outline"><img src="../../graphics/home.png"/></a>
<a href="mailto:tkennedy@odu.edu?subject=CS263%2C%20Types%20of%20Tests"><img src="../../graphics/email.png" title="Email to instructor"/></a><span style="margin: 0 32px;"/></td><td class="slideshowcontrolRight"/></tr></table></div><div class="copyright">© 2015-2023, Old Dominion Univ.</div></body></html>
